#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROW_COUNT 6
#define COLUMN_COUNT 7
#define EMPTY 0
#define PLAYER_PIECE 1
#define AI_PIECE 2
#define WINDOW_LENGTH 4
#define DEPTH 5

int board[ROW_COUNT][COLUMN_COUNT] = {0};
int nodes_searched = 0;

// Utility functions
void print_board() {
    printf("\n");
    for(int r = ROW_COUNT-1; r >= 0; r--) {
        for(int c = 0; c < COLUMN_COUNT; c++) {
            if(board[r][c] == PLAYER_PIECE) printf(" X ");
            else if(board[r][c] == AI_PIECE) printf(" O ");
            else printf(" . ");
        }
        printf("\n");
    }
    printf("\n");
}

int is_valid_location(int col) {
    return board[ROW_COUNT-1][col] == EMPTY;
}

int get_next_open_row(int col) {
    for(int r = 0; r < ROW_COUNT; r++)
        if(board[r][col] == EMPTY) return r;
    return -1; // Column full
}

void drop_piece(int row, int col, int piece) {
    board[row][col] = piece;
}

int winning_move(int piece) {
    // Horizontal
    for(int r = 0; r < ROW_COUNT; r++)
        for(int c = 0; c < COLUMN_COUNT-3; c++)
            if(board[r][c]==piece && board[r][c+1]==piece && board[r][c+2]==piece && board[r][c+3]==piece)
                return 1;
    // Vertical
    for(int c = 0; c < COLUMN_COUNT; c++)
        for(int r = 0; r < ROW_COUNT-3; r++)
            if(board[r][c]==piece && board[r+1][c]==piece && board[r+2][c]==piece && board[r+3][c]==piece)
                return 1;
    // Positive diagonal
    for(int r = 0; r < ROW_COUNT-3; r++)
        for(int c = 0; c < COLUMN_COUNT-3; c++)
            if(board[r][c]==piece && board[r+1][c+1]==piece && board[r+2][c+2]==piece && board[r+3][c+3]==piece)
                return 1;
    // Negative diagonal
    for(int r = 3; r < ROW_COUNT; r++)
        for(int c = 0; c < COLUMN_COUNT-3; c++)
            if(board[r][c]==piece && board[r-1][c+1]==piece && board[r-2][c+2]==piece && board[r-3][c+3]==piece)
                return 1;
    return 0;
}

// Heuristic scoring
int score_window(int window[WINDOW_LENGTH], int piece) {
    int score = 0, opp_piece = (piece == PLAYER_PIECE ? AI_PIECE : PLAYER_PIECE);
    int piece_count = 0, empty_count = 0, opp_count = 0;
    for(int i=0;i<WINDOW_LENGTH;i++) {
        if(window[i] == piece) piece_count++;
        else if(window[i] == EMPTY) empty_count++;
        else if(window[i] == opp_piece) opp_count++;
    }
    if(piece_count==4) score += 100;
    else if(piece_count==3 && empty_count==1) score += 5;
    else if(piece_count==2 && empty_count==2) score += 2;

    if(opp_count==3 && empty_count==1) score -= 4;
    else if(opp_count==2 && empty_count==2) score -= 1;

    return score;
}

int score_position(int piece) {
    int score = 0;

    // Center column
    int center_count = 0;
    for(int r=0;r<ROW_COUNT;r++)
        if(board[r][COLUMN_COUNT/2]==piece) center_count++;
    score += center_count*3;

    // Horizontal
    for(int r=0;r<ROW_COUNT;r++)
        for(int c=0;c<COLUMN_COUNT-3;c++){
            int window[WINDOW_LENGTH];
            for(int i=0;i<WINDOW_LENGTH;i++) window[i]=board[r][c+i];
            score += score_window(window, piece);
        }

    // Vertical
    for(int c=0;c<COLUMN_COUNT;c++)
        for(int r=0;r<ROW_COUNT-3;r++){
            int window[WINDOW_LENGTH];
            for(int i=0;i<WINDOW_LENGTH;i++) window[i]=board[r+i][c];
            score += score_window(window, piece);
        }

    // Positive diagonal
    for(int r=0;r<ROW_COUNT-3;r++)
        for(int c=0;c<COLUMN_COUNT-3;c++){
            int window[WINDOW_LENGTH];
            for(int i=0;i<WINDOW_LENGTH;i++) window[i]=board[r+i][c+i];
            score += score_window(window, piece);
        }

    // Negative diagonal
    for(int r=3;r<ROW_COUNT;r++)
        for(int c=0;c<COLUMN_COUNT-3;c++){
            int window[WINDOW_LENGTH];
            for(int i=0;i<WINDOW_LENGTH;i++) window[i]=board[r-i][c+i];
            score += score_window(window, piece);
        }

    return score;
}

// Minimax algorithm with alpha-beta pruning
int minimax(int depth, int alpha, int beta, int maximizingPlayer, int *best_col) {
    nodes_searched++;
    int valid_cols[COLUMN_COUNT], valid_count = 0;
    for(int c=0;c<COLUMN_COUNT;c++) if(is_valid_location(c)) valid_cols[valid_count++] = c;

    int terminal = winning_move(PLAYER_PIECE) || winning_move(AI_PIECE) || valid_count==0;

    if(depth==0 || terminal){
        if(terminal){
            if(winning_move(AI_PIECE)) return 100000;
            else if(winning_move(PLAYER_PIECE)) return -100000;
            else return 0;
        } else return score_position(AI_PIECE);
    }

    if(maximizingPlayer){
        int value = -1000000;
        for(int i=0;i<valid_count;i++){
            int col = valid_cols[i];
            int row = get_next_open_row(col);
            board[row][col] = AI_PIECE;
            int new_score = minimax(depth-1, alpha, beta, 0, best_col);
            board[row][col] = EMPTY;
            if(new_score > value){
                value = new_score;
                if(depth == DEPTH) *best_col = col;
            }
            if(value > alpha) alpha = value;
            if(alpha >= beta) break;
        }
        return value;
    } else {
        int value = 1000000;
        for(int i=0;i<valid_count;i++){
            int col = valid_cols[i];
            int row = get_next_open_row(col);
            board[row][col] = PLAYER_PIECE;
            int new_score = minimax(depth-1, alpha, beta, 1, best_col);
            board[row][col] = EMPTY;
            if(new_score < value) value = new_score;
            if(value < beta) beta = value;
            if(alpha >= beta) break;
        }
        return value;
    }
}

// Main game
int main() {
    srand(time(NULL));
    int turn, game_over = 0;
    int col, best_col;

    // Ask who starts first
    printf("Who starts first? (0=Player, 1=AI): ");
    scanf("%d", &turn);

    print_board();
    while(!game_over){
        if(turn == 0){
            printf("Player turn (0-6): ");
            scanf("%d", &col);
            if(is_valid_location(col)){
                int row = get_next_open_row(col);
                drop_piece(row, col, PLAYER_PIECE);
                if(winning_move(PLAYER_PIECE)){
                    print_board();
                    printf("PLAYER WINS!\n");
                    game_over = 1;
                }
                turn = 1;
            } else printf("Invalid move.\n");
        } else {
            minimax(DEPTH, -1000000, 1000000, 1, &best_col);
            col = best_col;
            if(is_valid_location(col)){
                int row = get_next_open_row(col);
                drop_piece(row, col, AI_PIECE);
                printf("AI plays column %d\n", col);
                if(winning_move(AI_PIECE)){
                    print_board();
                    printf("AI WINS!\n");
                    game_over = 1;
                }
                turn = 0;
            }
        }
        print_board();
    }
    printf("Nodes searched: %d\n", nodes_searched);
    return 0;
}
